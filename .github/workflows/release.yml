name: Release

on:
  push:
    branches: [main]

jobs:
  release:
    runs-on: ubuntu-latest

    permissions:
      contents: write

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"

      - name: Set up Python
        run: uv python install 3.12

      - name: Extract version from pyproject.toml
        id: version
        run: |
          VERSION=$(grep -E "^version = " pyproject.toml | head -1 | sed 's/version = "\(.*\)"/\1/')
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag=v$VERSION" >> $GITHUB_OUTPUT

      - name: Check if release already exists
        id: check_release
        run: |
          if gh release view "v${{ steps.version.outputs.version }}" > /dev/null 2>&1; then
            echo "exists=true" >> $GITHUB_OUTPUT
          else
            echo "exists=false" >> $GITHUB_OUTPUT
          fi
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Build package
        if: steps.check_release.outputs.exists == 'false'
        run: uv build

      - name: Gather release context
        if: steps.check_release.outputs.exists == 'false'
        id: context
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")

          # Collect commits since last tag
          if [ -n "$LAST_TAG" ]; then
            COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s (%h)" --no-merges)
          else
            COMMITS=$(git log -20 --pretty=format:"- %s (%h)" --no-merges)
          fi

          # Collect merged PR titles and bodies
          if [ -n "$LAST_TAG" ]; then
            TAG_DATE=$(git log -1 --format=%aI "$LAST_TAG")
            PRS=$(gh pr list --state merged --search "merged:>=${TAG_DATE}" --json title,body,number --limit 50 \
              --jq '.[] | "### PR #\(.number): \(.title)\n\(.body // "No description.")\n"' 2>/dev/null || echo "")
          else
            PRS=""
          fi

          # Collect short diffstat
          if [ -n "$LAST_TAG" ]; then
            DIFFSTAT=$(git diff --stat "${LAST_TAG}..HEAD" | tail -1)
          else
            DIFFSTAT=$(git diff --stat HEAD~10..HEAD | tail -1)
          fi

          # Write context to file for the LLM
          cat > /tmp/release_context.txt << CTXEOF
          Version: ${VERSION}
          Previous version: ${LAST_TAG:-"(first release)"}
          Diffstat: ${DIFFSTAT}

          ## Commits
          ${COMMITS}

          ## Pull Requests
          ${PRS}
          CTXEOF

          echo "context_file=/tmp/release_context.txt" >> $GITHUB_OUTPUT
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Generate AI release summary
        if: steps.check_release.outputs.exists == 'false' && env.HAS_ANTHROPIC_KEY == 'true'
        id: ai_summary
        run: |
          CONTEXT=$(cat /tmp/release_context.txt)
          VERSION="${{ steps.version.outputs.version }}"

          # Call Anthropic API to generate release summary
          RESPONSE=$(curl -s https://api.anthropic.com/v1/messages \
            -H "content-type: application/json" \
            -H "x-api-key: $ANTHROPIC_API_KEY" \
            -H "anthropic-version: 2023-06-01" \
            -d "$(jq -n \
              --arg context "$CONTEXT" \
              --arg version "$VERSION" \
              '{
                model: "claude-sonnet-4-5-20250514",
                max_tokens: 1024,
                messages: [{
                  role: "user",
                  content: ("You are writing release notes for an open-source Python project called LegacyLipi (a PDF translator for legacy Indian font encodings). Generate a concise, professional release summary for v" + $version + ".\n\nRules:\n- Start with a 1-2 sentence highlight of what this release brings\n- Group changes into sections: Features, Fixes, Breaking Changes (only if applicable)\n- Use bullet points, keep each point to one line\n- Do NOT include installation instructions (added separately)\n- Do NOT use emojis\n- Be factual, derive everything from the context below\n- If this is a major version bump, mention it\n\nContext:\n" + $context)
                }]
              }')" \
          )

          # Extract the text content from the response
          SUMMARY=$(echo "$RESPONSE" | jq -r '.content[0].text // empty')

          if [ -n "$SUMMARY" ]; then
            echo "$SUMMARY" > /tmp/ai_summary.md
            echo "generated=true" >> $GITHUB_OUTPUT
          else
            echo "generated=false" >> $GITHUB_OUTPUT
            echo "API response: $RESPONSE" >&2
          fi
        env:
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          HAS_ANTHROPIC_KEY: ${{ secrets.ANTHROPIC_API_KEY != '' }}

      - name: Compose release notes
        if: steps.check_release.outputs.exists == 'false'
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          AI_GENERATED="${{ steps.ai_summary.outputs.generated || 'false' }}"

          if [ "$AI_GENERATED" = "true" ]; then
            # Use AI summary + auto-generated PR list
            cp /tmp/ai_summary.md release_notes.md
          else
            # Fallback: use commit list
            LAST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "")
            if [ -n "$LAST_TAG" ]; then
              COMMITS=$(git log ${LAST_TAG}..HEAD --pretty=format:"- %s" --no-merges)
            else
              COMMITS=$(git log -20 --pretty=format:"- %s" --no-merges)
            fi

            cat > release_notes.md << EOF
          ## What's Changed

          ${COMMITS}
          EOF
          fi

          # Append installation instructions
          cat >> release_notes.md << EOF

          ---

          ### Installation

          \`\`\`bash
          pip install legacylipi==${VERSION}
          uv tool install legacylipi==${VERSION}
          uvx legacylipi api
          \`\`\`
          EOF

      - name: Create GitHub Release
        if: steps.check_release.outputs.exists == 'false'
        run: |
          gh release create "${{ steps.version.outputs.tag }}" \
            dist/legacylipi-${{ steps.version.outputs.version }}-py3-none-any.whl \
            dist/legacylipi-${{ steps.version.outputs.version }}.tar.gz \
            --title "v${{ steps.version.outputs.version }}" \
            --notes-file release_notes.md
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Publish to PyPI
        if: steps.check_release.outputs.exists == 'false'
        uses: pypa/gh-action-pypi-publish@release/v1
        with:
          password: ${{ secrets.PYPI_API_TOKEN }}

      - name: Skip release (already exists)
        if: steps.check_release.outputs.exists == 'true'
        run: |
          echo "Release v${{ steps.version.outputs.version }} already exists, skipping."
